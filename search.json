[
  {
    "objectID": "posts/projects/artwork_classifier/index.html",
    "href": "posts/projects/artwork_classifier/index.html",
    "title": "Classifying Artwork Types With Fastai",
    "section": "",
    "text": "I’ve always been interested in how machine learning can apply to visual arts. In particular, computer vision feels like the most direct application to art since we can build programs to classify, modify, and even generate visuals in an artistic fashion!\nI’m by no means a deep learning aficionado but it’s exciting to tinker around with the different tools and concepts I have at my disposal. In this notebook, we will be exploring how to build out an image classification model which classifies artwork based on their different types.\nWe’ll be using the fastai framework to speed up the development process and utilize modern deep learning techniques. Along the way, I will also be covering several different concepts that I have found useful in implementing vision models. I assume some level of familiarity with machine learning concepts such as epochs and mini-batch gradient descent. And ultimately, my hope is for this notebook to become the start of projects that inspire and help other deep learning practitioners along their own journeys!"
  },
  {
    "objectID": "posts/projects/artwork_classifier/index.html#dataloader-function",
    "href": "posts/projects/artwork_classifier/index.html#dataloader-function",
    "title": "Classifying Artwork Types With Fastai",
    "section": "4.1 Dataloader Function",
    "text": "4.1 Dataloader Function\n\n\nCode\ndef get_dls(bs: int, size: int) -&gt; DataLoaders:\n    \"\"\"\n    Creates a dataloader for an image recognition task with specified batch size and image size.\n\n    # Parameters:\n    -   bs (int): Batch size.\n    -   size (int): Final size of individual images.\n\n    # Returns:\n    -   DataLoaders: A dataloader that batches our image data with specific image and batch size.\n    \"\"\"\n    db = DataBlock(\n        blocks=(ImageBlock(), CategoryBlock()),\n        get_items=get_image_files,\n        splitter=RandomSplitter(seed=42), \n        get_y=parent_label,\n        item_tfms=Resize(460),\n        batch_tfms=aug_transforms(size=size, min_scale=0.75)\n    )\n    return db.dataloaders(data_path / 'training_set', bs=bs)\n\n\nWhen we create our dataloader, we can verify that our splitter is working as we expect it to.\n\n\nCode\ndls = get_dls(64, 128)\nlen(dls.train_ds), len(dls.valid_ds)\n\n\n(6177, 1544)\n\n\nNow, let’s check out what images we have to work with using the show_batch function!\n\n\nCode\n# Show an example batch of images\ndls.show_batch()"
  },
  {
    "objectID": "posts/projects/artwork_classifier/index.html#learning-rate-finder",
    "href": "posts/projects/artwork_classifier/index.html#learning-rate-finder",
    "title": "Classifying Artwork Types With Fastai",
    "section": "5.1 Learning Rate Finder",
    "text": "5.1 Learning Rate Finder\nFor our model, we first need to select a good learning rate to start our training. Fastai implements a learning rate finder method Learner.lr_find based on Leslie Smith’s paper called Cyclical Learning Rates for Training Neural Networks.\nSmith describes his approach as the following:\n\nThere is a simple way to estimate reasonable minimum and maximum boundary values with one training run of the network for a few epochs. It is a “LR range test”; run your model for several epochs while letting the learning rate increase linearly between low and high LR values.\n\nEssentially, we check our training losses as we grow our learning rate to get an idea of what learning rate performs well.\nFastai takes a slightly different approach: The model is test-trained with learning rates that grow exponentially from a low learning rate to a higher learning rate across a number of mini-batches. The process continues until we find a learning rate where the loss begins to diverge and increases significantly.\nWhat this boils down to is that in the fastai version we don’t necessarily need to run for multiple epochs to get an optimal learning rate as we are training for a set number of mini-batches.\nConveniently, lr_find gives us the loss vs. learning rate plot and also enables us to directly extract learning rates that could be optimal based off different suggestion functions. For example, we can use steep which gets the learning rate with the steepest slope.\n\n\nCode\nlr_steep = learn.lr_find(suggest_funcs=steep)\n\n\n\nLog plot of loss vs. learning rate"
  },
  {
    "objectID": "posts/projects/artwork_classifier/index.html#one-cycle-idea",
    "href": "posts/projects/artwork_classifier/index.html#one-cycle-idea",
    "title": "Classifying Artwork Types With Fastai",
    "section": "5.2 One-cycle Idea",
    "text": "5.2 One-cycle Idea\nWe can now start training our model! Using the fit_one_cycle method we are actually training our model with what is called the one-cycle policy, an idea that again comes from Leslie Smith and changes our learning rate over the course of training. I won’t be going into close detail on how the 1cycle policy is implemented in the scope of this article.\nAt a high level, we are starting at some initial learning rate, linearly increasing our learning rate after every batch up to a maximum learning rate, and from the maximum learning rate down to some minimum learning rate several magnitudes lower than our initial learning rate.\nThe idea behind this all is to warm up our training with a low learning rate and use the high learning rate to help find minimums in our loss function that are flatter, allowing the model to generalize better.\nDuring the last segment of training, the descending learning rates help the optimizer avoid skipping over a steeper loss within the flatter areas. This process allows our model to converge faster and consequently achieve better results with lower iterations than traditional training methods. Smith calls this occurrence super-convergence.\n\n\nCode\ndef plot_example_cycle(x_min, x_max, y_min, y_max, padding):\n    values = 100\n    x = np.linspace(x_min, x_max, values + padding)\n\n    y1 = np.linspace(y_min, y_max, values // 2, endpoint=False)\n    y2 = np.linspace(y_max, y_min, values // 2, endpoint=False)\n    padded_values = np.linspace(y_min, y_min * 1e-2, padding)\n\n    y = np.concatenate((y1, y2, padded_values))\n\n    plt.plot(x, y)\n    plt.xlabel('Epochs')\n    plt.ylabel('Learning rate')\n    plt.show()\n\n\n\n\nCode\nplot_example_cycle(0, 40, 0.001, 0.01, 15)\n\n\n\n\n\nFigure 1: Example representation of a linear 1cycle learning rate schedule.\n\n\n\n\n\nWith transfer learning, our model has additional new layers that we can train for the problem we are trying to solve. At the start of training, we may not want to completely readjust the weights in the model’s previously learned layers because they account for high-level details of the image like line and shape.\nIn a pretrained model, the previous trained layers start out frozen, meaning their weights aren’t updated during training unless we unfreeze them. Later, we will unfreeze all the layers and use a range of learning rates to help adjust them slightly for our artwork classification.\nFastai recommends training the frozen pretrained model for a few epochs before training the full pretrained model. We’ll start with 3 epochs frozen using the learning rate we found before and then train the full model for 15 epochs. We can get an idea of how our error rates changes across training from here. Our losses along with our metrics will be useful in determining if we’ve fitted a decent model or whether we are underfitting or overfitting.\n\n\nCode\nlearn.fit_one_cycle(3, lr_steep.steep)\n\n\n\n\n\nepoch\ntrain_loss\nvalid_loss\naccuracy\ntime\n\n\n\n\n0\n0.724909\n0.375700\n0.872409\n00:10\n\n\n1\n0.425733\n0.282166\n0.894430\n00:10\n\n\n2\n0.341481\n0.281355\n0.898964\n00:10\n\n\n\n\n\nNow we can unfreeze the layers and find a new learning rate to train on:\n\n\nCode\nlearn.unfreeze()\nlearn.lr_find()\n\n\n\n\n\nSuggestedLRs(valley=3.630780702224001e-05)\n\n\n\n\n\n\n\nCode\nlearn.fit_one_cycle(15, 1e-5)\n\n\n\n\n\nepoch\ntrain_loss\nvalid_loss\naccuracy\ntime\n\n\n\n\n0\n0.271441\n0.265777\n0.904145\n00:12\n\n\n1\n0.296644\n0.251294\n0.908031\n00:11\n\n\n2\n0.278119\n0.242461\n0.913860\n00:11\n\n\n3\n0.229598\n0.223756\n0.912565\n00:11\n\n\n4\n0.219047\n0.216550\n0.919689\n00:11\n\n\n5\n0.199054\n0.201101\n0.922280\n00:11\n\n\n6\n0.181958\n0.206481\n0.924223\n00:12\n\n\n7\n0.153299\n0.190849\n0.929404\n00:11\n\n\n8\n0.152870\n0.189614\n0.929404\n00:11\n\n\n9\n0.144226\n0.188413\n0.929404\n00:11\n\n\n10\n0.139311\n0.187798\n0.931995\n00:11\n\n\n11\n0.134395\n0.202066\n0.927461\n00:11\n\n\n12\n0.142067\n0.192524\n0.927461\n00:11\n\n\n13\n0.129715\n0.187295\n0.928756\n00:11\n\n\n14\n0.125194\n0.191619\n0.930699\n00:11"
  },
  {
    "objectID": "posts/projects/artwork_classifier/index.html#interpreting-the-loss-curves-further-training",
    "href": "posts/projects/artwork_classifier/index.html#interpreting-the-loss-curves-further-training",
    "title": "Classifying Artwork Types With Fastai",
    "section": "5.3 Interpreting the Loss Curves, Further Training?",
    "text": "5.3 Interpreting the Loss Curves, Further Training?\nAfter training our model, we will see how our training and validation losses have changed over the course of our iteration / epochs using loss curves. Loss curves won’t provide the entire story of our model but we’ll have a broad picture of how our model performs over the selected dataset and batch size. Figure 2 shows the loss curves across the training iterations.\n\n\nCode\nlearn.recorder.plot_loss()\nplt.xlabel(\"Iterations\")\nplt.ylabel(\"Loss\")\nplt.title('Loss Curves Across Iterations')\nplt.show()\n\n\n\n\n\nFigure 2: Loss curves across the model’s training iterations\n\n\n\n\nInitially, our validation loss starts out lower than our training loss but our training loss quickly converges as our training progresses.\nWe should note that we reach a point where our validation loss is higher than our training loss and stagnates a bit. The model is becoming overconfident in its predictions and we have to ask ourselves: are we overfitting?\nFigure 3 shows the loss curves across the training epochs in case we need to go back and retrain our model to a previous epoch.\n\n\nCode\ntrain_loss = L(learn.recorder.values).itemgot(0)\nvalid_loss = L(learn.recorder.values).itemgot(1)\n\nplt.plot(train_loss)\nplt.plot(valid_loss)\nplt.xlabel('Epoch')\nplt.ylabel('Loss')\nplt.title('Loss Curves Across Epochs')\nplt.show()\n\n\n\n\n\nFigure 3: Loss curves across training epochs"
  },
  {
    "objectID": "posts/projects/artwork_classifier/index.html#overfitting",
    "href": "posts/projects/artwork_classifier/index.html#overfitting",
    "title": "Classifying Artwork Types With Fastai",
    "section": "5.4 Overfitting",
    "text": "5.4 Overfitting\nOverfitting occurs when we have trained for too long and the model begins to “memorize” the training data while failing to generalize well to new data.\nWhen we look at our losses visually, we can see that there is an emerging gap between our training and validation loss and the latter seems to stagnate. How big of a gap is too big? It’s hard to say because it depends on a variety of factors like the scale of the dataset.\nWe could stop early at a point where the gap isn’t as large, but with one-cycle training that may not be a good idea because we may not allow our learning rate to reach the small values that would benefit our training.\nHowever, one key takeaway from fastai is that we should be checking to see if our performance metrics are getting significantly worse to decide is the model is overfitting. It’s not enough to view the losses alone.\nFigure 4 shows the accuracy across the training epochs.\n\n\nCode\naccuracy_metric = L(learn.recorder.values).itemgot(2)\nhighest_accuracy_epoch = np.argmax(accuracy_metric)\nprint(f'Highest accuracy during last run: {highest_accuracy_epoch}')\n\nplt.xlabel('Accuracy')\nplt.ylabel('Epoch')\nplt.title('Accuracy Across Epochs')\nplt.xticks(np.arange(0, len(accuracy_metric) + 1, 5))\n\nplt.plot(accuracy_metric)\nplt.scatter(highest_accuracy_epoch, accuracy_metric[highest_accuracy_epoch], color='orange')\nplt.show()\n\n\nHighest accuracy during last run: 10\n\n\n\n\n\nFigure 4: Accuracy across the training epochs\n\n\n\n\nOur highest accuracy is at epoch 10 but the accuracy appears to be flattening out a bit overall. If we take into account both our validation loss and metric, then our model might be overfitting. Fortunately, we have a few options here! We could introduce weight decay or even rerun our model with a lower number of epochs and adjust from there. In this case, we will add some weight decay using discriminative learning rates.\nWe should keep in mind that our performance metric is what ultimately matters in practice.\nAs Jeremy Howard states:\n\n“In the end what matters is your accuracy, or more generally your chosen metrics, not the loss. The loss is just the function we’ve given the computer to help us to optimize.”\n“Remember, it’s not just that we’re looking for the validation loss to get worse, but the actual metrics. Your validation loss will first get worse during training because the model gets overconfident, and only later will get worse because it is incorrectly memorizing the data. We only care in practice about the latter issue. Remember, our loss function is just something that we use to allow our optimizer to have something it can differentiate and optimize; it’s not actually the thing we care about in practice.”\n\nTo really evaluate our model’s performance, we would run our model on a representative test data set that it has never seen before. This will allow us to get a more honest assessment of how our model is doing and we don’t want to report accuracy on our training model alone. Once we’ve decided on a model, we’ll look at how we can use the images we didn’t use for training as a test set.\n\n\nCode\n# Reinitialize our model to restart training\nlearn = vision_learner(dls, resnet50, metrics=accuracy, wd=0.1)\n\n\n\n\nCode\nlr_steep = learn.lr_find(suggest_funcs=steep, show_plot=False)\n\nlearn.fit_one_cycle(3, lr_steep.steep)\n\n\n\n\n\nepoch\ntrain_loss\nvalid_loss\naccuracy\ntime\n\n\n\n\n0\n0.872535\n0.414252\n0.854922\n00:10\n\n\n1\n0.518426\n0.336665\n0.879534\n00:10\n\n\n2\n0.387601\n0.325532\n0.884715\n00:10\n\n\n\n\n\n\n\nCode\nlearn.unfreeze()\nlearn.lr_find()\n\n\n\n\n\nSuggestedLRs(valley=0.00013182566908653826)\n\n\n\n\n\n\n\nCode\nlearn.fit_one_cycle(15, lr_max=slice(1e-6, 1e-4))\n\n\n\n\n\nepoch\ntrain_loss\nvalid_loss\naccuracy\ntime\n\n\n\n\n0\n0.348780\n0.305213\n0.893782\n00:11\n\n\n1\n0.356950\n0.302995\n0.891839\n00:11\n\n\n2\n0.313423\n0.268401\n0.902202\n00:11\n\n\n3\n0.268710\n0.242577\n0.911269\n00:11\n\n\n4\n0.239830\n0.247199\n0.913212\n00:11\n\n\n5\n0.214128\n0.237627\n0.913212\n00:11\n\n\n6\n0.189272\n0.214587\n0.919689\n00:11\n\n\n7\n0.174895\n0.214508\n0.919041\n00:11\n\n\n8\n0.153856\n0.211521\n0.920337\n00:11\n\n\n9\n0.137692\n0.201288\n0.927461\n00:11\n\n\n10\n0.137655\n0.202045\n0.927461\n00:11\n\n\n11\n0.133422\n0.198879\n0.927461\n00:11\n\n\n12\n0.126204\n0.191793\n0.928756\n00:11\n\n\n13\n0.117809\n0.196178\n0.926166\n00:11\n\n\n14\n0.116607\n0.195831\n0.928756\n00:11\n\n\n\n\n\nOur accuracy is about the same, but our loss curves a bit smoother and our validation loss in particular shows a smoother, more consistent decreasing trend. For now, we’ll move forward with this model.\n\n\nCode\nlearn.recorder.plot_loss()\nplt.xlabel(\"Iterations\")\nplt.ylabel(\"Loss\")\nplt.title('Loss Curves Across Iterations')\nplt.show()\n\n\n\n\n\nFigure 5: Loss curves across the model’s training iterations\n\n\n\n\n\n\nCode\ntrain_loss = L(learn.recorder.values).itemgot(0)\nvalid_loss = L(learn.recorder.values).itemgot(1)\n\nplt.plot(train_loss)\nplt.plot(valid_loss)\nplt.xlabel('Epoch')\nplt.ylabel('Loss')\nplt.title('Loss Curves Across Epochs')\nplt.show()\n\n\n\n\n\nFigure 6: Loss curves across training epochs\n\n\n\n\n\n\nCode\naccuracy_metric = L(learn.recorder.values).itemgot(2)\nhighest_accuracy_epoch = np.argmax(accuracy_metric)\nprint(f'Highest accuracy during last run: {highest_accuracy_epoch}')\n\nplt.xlabel('Accuracy')\nplt.ylabel('Epoch')\nplt.title('Accuracy Across Epochs')\nplt.xticks(np.arange(0, len(accuracy_metric) + 1, 5))\n\nplt.plot(accuracy_metric)\nplt.scatter(highest_accuracy_epoch, accuracy_metric[highest_accuracy_epoch])\nplt.show()\n\n\nHighest accuracy during last run: 12\n\n\n\n\n\nFigure 7: Accuracy across the training epochs\n\n\n\n\nOur accuracy metric seems to be increasing overall. The model is definitely learning patterns about the data and seems like it could potentially generalize well to similar data.\nWe can use a confusion matrix to see the number of correctly classified and misclassified images on our training set. Figure 8 displays the confusion matrix for the model we just fine-tuned.\n\n\n\nCode\ninterp = ClassificationInterpretation.from_learner(learn)\ninterp.plot_confusion_matrix()\n\n\n\n\n(a) Confusion matrix on the training set\n\n\n\n\n\n\n(b)\n\n\n\nFigure 8: ?(caption)\n\n\nWe can also display a report with common classification metrics like precision, recall, and the F1-score. For this project, we are mainly focused on the F1-score.\nThe weighted F1-score is the the mean of all the class F1 scores while taking into account the number of occurrences in each class. In general, we are aiming for a balance between precision and recall on a scale between 0 and 1. Our model achieved a weighted F1-score of 0.930 on the training set.\n\n\nCode\ninterp.print_classification_report()\n\n\n\n\n\n              precision    recall  f1-score   support\n\n    drawings       0.83      0.69      0.75       213\n   engraving       0.74      0.88      0.81       158\n iconography       0.97      0.99      0.98       418\n    painting       0.97      0.96      0.96       409\n   sculpture       0.97      0.99      0.98       346\n\n    accuracy                           0.93      1544\n   macro avg       0.90      0.90      0.90      1544\nweighted avg       0.93      0.93      0.93      1544\n\n\n\nFigure 9 shows the top 10 losses of training images predicted by our model. We can use this to get a visual idea of what kinds of images our model might be misclassifying.\nIn particular, from both the classification report and the top losses our model seems to misclassify engravings and drawings more than other types of art. Maybe not all images are standardized and there are definitely tough cases where the line between painting, drawing, and iconography are blurry.\n\n\n\nCode\ninterp.plot_top_losses(10)\n\n\n\n\n(a) Top 10 losses of images in the training set\n\n\n\n\n\n\n(b)\n\n\n\nFigure 9: ?(caption)\n\n\n\nIt’s fascinating that we are able to classify images at all with these results with a bit of conceptual understanding and a few lines of code! However, we still need to evaluate on the test set for reporting purposes."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Cracking Data with Yang",
    "section": "",
    "text": "Classifying Artwork Types With Fastai\n\n\n\n\n\n\n\nproject\n\n\nmachine learning\n\n\ncomputer vision\n\n\n\n\n\n\n\n\n\n\n\nSep 27, 2023\n\n\nYang Chen\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Cracking Data is all about my love for experimenting with data. It’s a collection of articles which help explain awesome tools, concepts, and projects through the context of disciplines that I am passionate about like art and martial arts!\nWho am I? I’m a data science Master’s student who’s interested in AI, deep learning, and explainable data science. I aim to keep my work fun and informative so others might be inspired to share their own experiments."
  }
]